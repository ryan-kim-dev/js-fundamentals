# 모딥다 15장. let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

식별자의 역할은 값을 구별하는 것이므로 식별자의 이름은 스코프 내에서 유일해야 한다. 하지만 `var` 키워드로 선언한 변수는 중복 선언이 가능하다. 이때 선언이 두번 되는 것은 아니다. `var` 키워드로 선언한 변수를 중복 선언한 결과는 초기화문 유무에 따라 달라진다.
중복된 변수 선언문에 초기화문이 있는 경우 중복된 변수는 해당 값으로 재할당되며 초기화문이 없는 변수 선언문인 경우엔 무시된다.

```js
var x = 1;
var y = 1;

// var 키워드로 선언한 변수는 같은 스코프 내에서 중복 선언이 가능하다.
// 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. 즉, 재할당이 이뤄진다.
var x = 100;
// 초기화문이 없는 변수 선언문은 무시된다.
var y;
console.log(x); // 100
console.log(y); // 1
```

### 15.1.2 함수 레벨 스코프

`var` 키워드로 선언한 변수는 오직 함수 몸체 내부(함수의 코드 블록)만을 지역 스코프로 인정한다. 함수 몸체 외부에서 `var` 키워드로 선언한 변수는 코드 블록 내에서 선언되었다고 하더라도 모두 전역 변수가 된다.

```js
var x = 1;

if (true) {
  var x = 10;
}
console.log(x); // 10
```

if문의 코드 블럭 내에서 선언한 변수 x는 전역 변수가 된다. 따라서 기존 전역 변수 x의 값에 재할당이 일어난다.

```js
var i = 10;

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}
console.log(i); // 5
```

for문의 변수 선언문에서 선언한 i 변수도 전역 변수가 된다. 따라서 기존 전역 변수 i의 값에 재할당이 일어난다.

### 15.1.3 변수 호이스팅

`var` 키워드로 선언한 변수는 변수 호이스팅으로 인해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 변수 선언문 이전에 변수를 참조할 수 있다. 단, 변수 선언문 이전에 변수에 접근하면 `undefined`를 반환한다.
왜 `undefined`가 반환되냐면, 런타임 이전에 자바스크립트 엔진에 의해 변수 선언이 먼저 실행되어 실행 컨텍스트에 의해 선언과 동시에 `undefined`로 초기화되기 때문이다. 할당문은 런타임에 실행되므로 변수 선언문 이전에 변수에 접근하면 `undefined`를 반환한다.

## 15.2 let 키워드

앞서 살펴본 중복 선언과 변수 호이스팅 등 `var` 키워드의 여러 단점을 보완하기 위해 ES6에서 `let` 키워드를 도입하였다.

### 15.2.1 변수 중복 선언 금지

`let` 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생한다.
`Uncaught SyntaxError: Identifier 'bar' has already been declared`

```js
var foo = 123;
var foo = 456; // 문법 에러가 발생하지 않는다.

let bar = 123;
let bar = 456; // Uncaught SyntaxError: Identifier 'bar' has already been declared
```

### 15.2.2 블록 레벨 스코프

`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.
하지만 `let` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다. 함수도 코드 블록이므로 스코프를 만든다. 이 때 함수 내의 코드 블록의 스코프는 함수 레벨 스코프와 중첩된다. (함수 안에 for문이 있는 경우 for문의 코드 블록도 스코프를 만든다. 하단 예시 코드 참고)

따라서 함수 내에서 `let` 키워드로 선언된 변수는 지역 변수가 된다.

```js
let i = 10; // 전역 스코프

function foo() {
  let i = 100; // 함수 레벨 스코프

  for (let i = 0; i < 5; i++) {
    // 블록 레벨 스코프
    console.log(i); // 0 1 2 3 4 -> 블록 레벨 스코프
  }
  console.log(i); // 100 -> 함수 레벨 스코프
}

foo();
console.log(i); // 10 -> 전역 스코프
```

### 15.2.3 변수 호이스팅

- `var` 키워드로 선언한 변수는 변수 호이스팅이 발생하여 변수 선언문 이전에 변수에 접근할 수 있다.
- `let` 키워드로 선언한 변수 또한 변수 호이스팅이 발생한다. 하지만 `var` 키워드로 선언한 변수와 달리 변수 선언문 이전에 변수에 접근하면 `ReferenceError`가 발생한다.
- 왜냐하면, `let` 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행되기 때문에 변수 선언문에서 초기화 단계가 실행되기 전까지는 변수를 참조할 수 없기 때문이다.
  - 선언 단계: 런타임 이전에 JS 엔진에 의해 암묵적으로 실행됨
  - 초기화 단계: 런타임에 변수 선언문에 도달했을 때 실행됨
  - 변수 선언문 이전에 변수에 접근하면 초기화 단계가 실행되지 않으므로 `ReferenceError`가 발생한다.

```js
// 선언 단계는 런타임 이전에 실행된다.
// 하지만 초기화는 런타임에 변수 선언문에 도달했을 때 실행된다.

console.log(foo); // // ReferenceError: Cannot access 'foo' before initialization

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

- TDZ(Temporal Dead Zone) : 스코프의 시작부터 변수 선언문에 도달할 때까지 변수를 참조할 수 없는 구간
- 자바스크립트는 모든 선언(var, let, const, function, function\*, class)을 호이스팅한다. 하지만 ES6에서 도입된 `let`, `const`, `class` 키워드를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

```js
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

위 코드는 `let` 키워드 또한 변수 호이스팅이 일어남을 보여준다. 만약 변수 호이스팅이 일어나지 않는다면 전역 변수 foo가 출력되어야 한다. 하지만 지역 변수 `foo`가 호이스팅되어 `ReferenceError`가 발생한다.

### 15.2.4 전역 객체와 let

```js
// 브라우저 환경에서 실행해야 한다.
var foo = 1;
console.log(window.foo); // 1
console.log(foo); // 1

let bar = 2;
console.log(window.bar); // undefined -> 객체의 존재하지 않는 프로퍼티 접근 시 undefined를 반환한다.
console.log(bar); // 2
```

**브라우저 환경일 경우** `var` 키워드로 선언한 전역 변수는 `window` 전역 객체의 프로퍼티가 된다.
하지만 `let` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니고, 전역 렉시컬 환경의 선언적 환경 레코드에 존재하게 된다. 따라서 `window` 전역 객체의 프로퍼티가 아니므로 `window.foo`, `foo`와 같이 접근할 수 없다.

## 15.3 const 키워드

`const` 키워드는 상수(재할당이 금지된 변수)를 선언하기 위해 사용하나, 반드시 상수만을 위해 사용하지는 않는다.
`let` 키워드의 특징과 대부분 동일하나 몇가지 차이점이 있다.

- 공통점
  - 블록 레벨 스코프를 따른다.
  - 호이스팅이 일어나지만 TDZ가 존재하여 변수 선언문 이전에 변수에 접근하면 `ReferenceError`가 발생한다.
  - 변수 중복 선언이 금지된다.
  - 전역 스코프더라도 `window` 전역 객체의 프로퍼티가 되지 않는다.
- 차이점
  - 한번 초기화 된 이후에는 재할당할 수 없다.
  - 반드시 선언과 동시에 초기화해야 한다.
  - 값이 변하지 않는 상수나 객체에 사용하는 것이 일반적이다.
